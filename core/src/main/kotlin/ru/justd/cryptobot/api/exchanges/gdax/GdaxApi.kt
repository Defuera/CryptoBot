package ru.justd.cryptobot.api.exchanges.gdax

import com.google.gson.annotations.SerializedName
import com.google.gson.reflect.TypeToken
import okhttp3.Headers
import okhttp3.OkHttpClient
import okhttp3.Request
import ru.justd.cryptobot.CoreConfig
import ru.justd.cryptobot.api.exchanges.PollingExchange
import ru.justd.cryptobot.api.exchanges.RateResponse
import ru.justd.cryptobot.api.exchanges.exceptions.RequestFailed
import java.time.Instant
import java.util.*
import javax.crypto.Mac
import javax.crypto.spec.SecretKeySpec
import javax.management.RuntimeErrorException


/**
 * https://docs.gdax.com/
 */
class GdaxApi(val okHttpClient: OkHttpClient) : PollingExchange(okHttpClient) {

    companion object {
        const val NAME = "GDAX"

        private const val BASE_URL = "https://api.gdax.com"

        private const val CB_ACCESS_KEY = "CB-ACCESS-KEY" // The api key as a string.
        private const val CB_ACCESS_SIGN = "CB-ACCESS-SIGN" // The base64-encoded signature (see Signing a Message).
        private const val CB_ACCESS_TIMESTAMP = "CB-ACCESS-TIMESTAMP" // A timestamp for your request.
        private const val CB_ACCESS_PASSPHRASE = "CB-ACCESS-PASSPHRASE" // The passphrase you specified when creating the API key

        private val SHARED_MAC = Mac.getInstance("HmacSHA256")
    }


    //region PollingExchange

    /**
     * https://docs.gdax.com/#get-product-order-book
     */
    override fun getRateUrl(base: String, target: String) = "$BASE_URL/products/$base-$target/book"

    @Throws(RequestFailed::class)
    override fun parseRateResponse(bodyString: String, base: String, target: String): RateResponse {
        val envelope = gson.fromJson<Envelope>(bodyString, Envelope::class.java)
        if (envelope.bids != null) {
            return RateResponse(envelope.bids[0][0].toDouble(), base, target)
        } else {
            throw RequestFailed(envelope.errorMessage!!)
        }
    }

    @Suppress("ArrayInDataClass")
    private data class Envelope(

            @SerializedName("message")
            val errorMessage: String?,
            val sequence: Long?,
            /**
             *  [ price, size, num-orders ]
             */
            val bids: Array<Array<String>>?,
            /**
             * [ price, size, num-orders ]
             */
            val asks: Array<Array<String>>?
    )

    //endregion


    //region sign requests


    fun getOrders(): List<Order> {
        val endpoint = "/orders?status=all"
        val url = "$BASE_URL$endpoint"
        val method = "GET"

        val response = okHttpClient
                .newCall(
                        Request.Builder()
                                .get()
                                .headers(securityHeaders(endpoint, method, null))
                                .url(url)
                                .build()
                )
                .execute()

        val bodyString = response.body()?.string()
        if (bodyString != null && !bodyString.isNullOrBlank()) {
        println("$bodyString")
            val typeToken = object : TypeToken<List<Order>>(){}.type
            return gson.fromJson(bodyString, typeToken)
        } else {
            throw RuntimeException("Unexpected error occured")
        }
    }


    /**
     * The CB-ACCESS-SIGN header is generated by creating a sha256 HMAC using
     * the base64-decoded secret key on the prehash string for:
     * timestamp + method + requestPath + body (where + represents string concatenation)
     * and base64-encode the output.
     * The timestamp value is the same as the CB-ACCESS-TIMESTAMP header.
     * @param requestPath
     * @param method
     * @param body
     * @param timestamp
     * @return
     */
    fun signRequest(requestPath: String, method: String, body: String?, timestamp: String): String {
        try {
            val prehash = timestamp + method.toUpperCase() + requestPath + (body ?: "")
            val secretDecoded = Base64.getDecoder().decode(CoreConfig.GDAX_SECRET)
            val keyspec = SecretKeySpec(secretDecoded, "HmacSHA256")
            val sha256 = SHARED_MAC.clone() as Mac
            sha256.init(keyspec)
            return Base64.getEncoder().encodeToString(sha256.doFinal(prehash.toByteArray()))
        } catch (e: CloneNotSupportedException) {
            e.printStackTrace()
            throw RuntimeErrorException(Error("Cannot set up authentication headers."))
        } catch (e: Exception) {
            e.printStackTrace()
            throw RuntimeErrorException(Error("Cannot set up authentication headers."))
        }

    }


    fun securityHeaders(endpoint: String, method: String, jsonBody: String?): Headers {


        val timestamp = Instant.now().epochSecond.toString() + ""
//        val resource = endpoint.replace(getBaseUrl(), "")

        val headers = Headers.of(
                "accept", "application/json",
                "content-type", "application/json",
                CB_ACCESS_KEY, CoreConfig.GDAX_KEY,
                CB_ACCESS_SIGN, signRequest(endpoint, method, jsonBody, timestamp),
                CB_ACCESS_TIMESTAMP, timestamp,
                CB_ACCESS_PASSPHRASE, CoreConfig.GDAX_LICENCE
        )
//        headers.add("accept", "application/json")
//        headers.add("content-type", "application/json")
//        headers.add("CB-ACCESS-KEY", publicKey)
//        headers.add("CB-ACCESS-SIGN", signature.generate(resource, method, jsonBody, timestamp))
//        headers.add("CB-ACCESS-TIMESTAMP", timestamp)
//        headers.add("CB-ACCESS-PASSPHRASE", passphrase)

//        curlRequest(method, jsonBody, headers, resource)

        return headers
    }
}